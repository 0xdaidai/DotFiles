异常处理
----------

○标准库异常
exception <exception>
    bad_cast <typeinfo>：多态引用的转换失败
    bad_typeid <typeinfo>：目标为含有虚函数的类型的空指针
    bad_weak_ptr <memory>：构造weak_ptr失败
    bad_function_call <functional>：调用无目标的function类
    bad_alloc <new>：内存申请失败
    bad_array_new_length <new>：传给new的size不在有效范围
    logic_error <stdexcept>
        domain_error：数学库
        invalid_argument：bitset构造参数无效
        length_error：容器size超出限制
        out_of_range：数组类型的无效索引
        future_error <future>：异步
    runtime_error <stdexcept>
        range_error：wide string与byte string转换出错
        overflow_error：bitset转换为整型溢出
        underflow_error：算术下溢
        system_error <system_error>：并发
            ios::failure：stream出错
○基本使用
    ●.what()：根部基类exception的虚函数，返回const char*，异常类销毁后该C-string也不复存在
    ●.code()：返回error_code类对象
○error_code&error_condition
    ●区别：可移植性
        前者由编译器定义(OS相关)，后者为默认标准
    ●error_code：
        .category().name()
        .value()
        .message()
        .default_error_condition()
        .default_error_condition().category().name()
        .default_error_condition().value()
        .default_error_condition().message()
    ●对比信息：重载了与枚举值的比较运算符
        errc：<cerrno>
        io_errc：<ios>
        future_errc：<future>
○异常挂起
    ●current_exception()
    返回exception_ptr对象
    ●rethrow_exception(eptr)
    重新抛出exception_ptr对象
○构造异常类
    ●logic_error和runtime_error
    (const string&)
    (const char*)
    ●system_error
    (error_code)
    (error_code，const string&)
    (error_code，const char*)
    ▪提供make_error_code(errc)构造error_code

C头文件
----------

○常用C头文件
●<cstddef>：常用基础类型的定义
●<cstdlib>：程序退出处理
●<cstring>：内存底层操作
●<cctype>：字符比较
●<ctime>：日期时间输出函数
●<cmath>：数学库
●<cassert>：调试

○调试：<cassert>
    ●assert(expr)：若为false则报错并终止程序
    ●static_assert(expr, message)：可选描述文字
    ●NDEGUG：#define 之后退出调试模式
    ●编译器预处理宏：
    __func__、__FILE__、__LINE__、__TIME__、__DATE__

○选项处理：<unistd.h>短版 <getopt.h>长版
●getopt(argc，argv，optstring)
    ▪参数optstring：
    t: 代表必有参数，"紧跟"或"间隔"都被视为参数
    t::代表可选参数，只识别"紧跟"为参数
    ▪返回int表示选项字符，-1表示结束
    ▪全局变量：
    optarg：指向选项的参数，无对应则返回?
    optind：指向处理的argv索引
●getopt_long(argc, argv, optstring, longopt, longindex)
    ▪参数lopt：struct option*，最后一个必须全0
        const char *name：参数名称
        int has_arg：no/required/optional_argrument
        int *flag：不为NULL则*flag=val且返回0
        int val：指定匹配到该选项时返回的int值
    ▪参数lidx：int*，传入一个int指针存放lopt下标
    ▪规则同上，不过"紧跟"用=区别与选项，而且长选项可不用完整输入
●getopt_long_only(参数同上)
    ▪区别：-opt会优先解析为长选项，不符合再为短

○SIMD：<immintrin.h>
●利用alignas(32)对齐数组
●向量寄存器抽象类型： __m256，__m256d，__m256i
●加载到向量寄存器：
    _mm256_load_ps( float* )
    _mm256_load_pd( dounle* )
    _mm256_load_epi256( __m256i* )
●SIMD运算：
    _mm256_OP_ps( __m256, __m256 )
    _mm256_OP_pd( __m256d, __m256d )
    _mm256_OP_epi32( __m256i, __m256i )
    _mm256_OP_epi64( __m256i, __m256i )
●存储回内存：
    _mm256_store_ps( float* , __m256)
    _mm256_store_pd( dounle* , __m256d )
    _mm256_store_epi256( int* , __m256i )

通用工具
----------

○pair：<utility>
●构造函数和赋值：
支持实例隐式类型转换和移动语义(tuple同)
●逐块式构造：
利用std::piecewise_constructor避免冲突
●便捷函数：
如今可利用构造推断代替原来make_pair()
○tuple：<tuple>
●初始列：
不适用于tuple，但可用于pair
●tuple和pair的转换

○any：<any>
●任意时期可指向任意类型的的数据
●构造：
拷贝/移动构造成员
就地构造：std::in_place_type<>
●读取：
.has_value()、.type()
.any_cast<T&>()
●修改：
.operator=
.emplace<>()
.reset()

○variant：<variant>
●可存放指定类型中的一个对象
●构造：
默认构造第一个类型
拷贝/移动构造成员最佳匹配
就地构造：std::in_place_type<>/in_place_index<>
●读取：
.index()、hold_alternative<T>(a)
get<T>(a)、get<I>(a)
get_if<T>(&a)、get_if<I>(&a)
●修改：
.operator=()
visit(func，args...)
○optional：<optional>
●指向一个可能存在的指定类型的对象
●构造：
默认构造为std::nullopt
拷贝/移动构造目标
就地构造：in_place
●读取与修改：
operator bool，operator*，operator->
.value()：nullopt则抛出异常
.value_or()：nullopt则返回目标值

○shared_ptr：<memory>
●构造方式：
构造函数(new，deleter)：分配目标、引用计数
make_shared<>()：一次分配更快速
●错误问题：
循环依赖
多组指向
●复杂操作：
Aliasing构造函数
类型转换
●原子性操作
○weak_ptr：<memory>
●作用：
解决shared_ptr循环依赖
只能弱引用分享，不参与销毁共享对象
○unique_ptr：<memory>
●作用：自动安全的释放资源
●构造方式：
构造函数：<ptr，del>(ptr，del)
●拥有权：释放、转移
●动态数组：
有特例化版本，提供下标操作
●释放资源：
需要提供deleter的模板实参和构造函数实参

○numeric_limits：<limits>
●提供类型的算术信息
●十进制转浮点数：
因为十进制可能需要更多位来表示而导致精度丢失，因此只有[(N)/log2(10)]d个十进制数字能确定

○TypeTrait：<type_traits>
●类型判断式
●类型关系检验
●类型修饰符
●common_type_t<>与decay_t<>
●利用using别名，提供 typetrait_t<T>
代替 typename typetrait<T>::type
●使用：
::value返回std::true_type或std::false_type
::type返回修饰后的类型
●利用包装函数处理/过滤类型后调用工具函数
利用::value调用重载工具
利用::type转换类型传递给模板同时修改参数类型

○reference_wrapper：<functional>
●便捷函数：利用ref()和cref()
●提供到目标引用的转换from&to
●提供.get()返回目标引用才能调用成员函数
○function：<functional>
●运行时能够统一可调用类型的三种形式

○MinMax：<algorithm>
●接受初始列
●接受比较准则
○swap：<utility>
●利用move语义进行swap
○增补比较操作：<utility>
●用==和<完成四个比较
●定义于namespace std::rel_ops中

○ratio：<ratio>
●模板参数作分子(.num)与分母(.den)
●编译期运算、化简、报错 (::type与::value)
●预定义ratio类型

○Clock和Timer：<chrono>
●duration
提供.count()、::rep、::period
预定义duration类型，提供字面值后缀
算术运算：会隐式转换为更高精度(最大公约数)
类型转换：转为粗精度直接截断数值
●Clock
提供::duration、::time_point、::now()
预定义：system_clock、steady_clock等
system_clock：提供::from/to_time_t()
●time_point<Clock、duration>
由Clock提供Epoch，duration可相对为负值
默认初始化为Epoch
关系运算
类型转换
●<ctime>：
接受 time_t* 返回 tm* ：localtime()、gmtime()
●使用方法
获取time_point对象：Clock::now()+duration
获取duration：time_point、duration
最终目的：获取我们需要的时间长度或日期时间
STL
○STL组件
○容器：序列、关联、无序
●容器适配器
●异常发生：容器reallocate，元素的copy与move
●异常处理：容器保证reallocate安全，对于元素产生的异常，随机访问容器无法恢复，节点式容器保证安全
○迭代器：输出、输入、单向、双向、随机
●迭代器适配器
●注意迭代器失效的时机
○泛型算法：搜索比较、更替复制、涂写删除
●利用函数模板得以接受不同类型的迭代器及不同类型的可调用对象，并可以调用不同的重载函数

○array：<array>
●聚合类：
array未定义构造函数，只能使用聚合类初始化
○vector：<vector>
●与string不同，vector不能用.reserve()缩减容量
●接迭代器范围的构造函数是函数模板，故支持不同容器和元素类型转换(STL容器同)
●特例化版本：vector<bool>
以1bit存储bool，时间效率换空间效率
proxy技巧：将bool封装成类并保持原来的抽象
○deque：<deque>
●特点：
头尾快速插删、reallocate更快速、访问多一步骤
○list：<list>
●特点：
插入删除快速、节点安全
●需要提供反向迭代器并应该避免边界检查，故可能实现为环式（.end()与.rend()指向自己）
●.remove()和.remove_if()代替.erase()
●链表特殊更易型算法
○forward_list：<forward_list>
●无需提供反向迭代器，故无需环式，只要将最后元素*next设为nullptr（.before_begin()指向自己， .end()设为nullptr)
●容器操作特殊性：_after
○set与multiset：<set>
●严格弱序
非对称，可传递，非自反，等效传递
●自动排序
不可修改key值和比较准则从而打乱顺序破坏结构，由此导致插入、删除操作的特殊性(pos, bool, count)
若想改变上述两值，只有通过erase-insert、构造、赋值
●操作保证等价元素相对次序，且添加的等价元素排在后面
○map和multimap：<map>
●特殊搜索成员，比较key，返回value(pair)
●下标运算符：自动隐式构造元素
○Unordered：<unordered_set>、<unordered_map>
●bucket接口
●hash函数
○stack：<stack>
●默认deque
○queue：<queue>
●默认deque
○priority_queue：<queue>
●默认vector
●利用heap算法（完全二叉树）

○迭代器辅助函数：<iterator>
●advance()
●next()
●prev()
●distance()
●iter_swap()
○反向迭代器
●获取：通过容器成员函数
●提供 .base()转换为正常迭代器(+1)
○插入迭代器
●获取：通过泛型函数
back_inserter()
front_inserter()
inserter()
○流迭代器
●获取：类模板构造
istream_iterator<>()
ostream_iterator<>( , )
●只是通过I/O操作符实现，而非底层I/O，迭代器保存上次读取的值
○流缓冲区迭代器
●获取：类模板构造
istreambuf_iteratot<charT>
ostreambuf_iteratot<charT>
○移动迭代器
●获取：泛型函数获取
make_move_iterator()
●作算法源区间，需要保证元素只能处理一次

○泛型算法：<algorithm>、<numeric>、<execution>
●默认by value传递谓词，算法并不保证在类内保存状态的谓词能正确运作(拷贝谓词导致重置状态)
●获取谓词状态：
谓词指向外部状态
显式指定模板实参为reference
利用for_each()算法的返回值
●非更易型：搜索，比较
●更易型：涂写，移除，更替，复制
排序算法
集合算法
数值算法
●并行算法：第一参数为std::execution::par
●next_permutation()实现：
从end起搜寻非逆序点，
将右边逆序列中比该点大的最小值与该点swap，
原来的右边逆序列安正序重排

常用设施
○bitset：<bitset>
●方便访问指定位
○bytes：<bytes>
●方便长字节流位运算

○string：<string>
●string、wstring、u16string、u32string均由base_string特例化而来
●构造、赋值、插入、删除、替换、比较、搜寻
数值转换、子字符串、I/O操作
●参数：
范围：(i，l)、(b，e)
目标：(s)、(s，i)、(s，i，l)、(c)、(c，l)、(char)、(n，char)
○string_view：<string_view>
●原理：只是string或C-string的引用，没有数据的拥有权，只含有元数据
●目的：高效的提供string接口的拷贝操作，尤其.substr()
●注意：所有拷贝共享一个底层数据
●额外提供：.remove_prefix和.remove_suffix

○正则表达式：<regex>
●组件：
regex，sregex_iterator，sregex_token_iterator，smatch，ssub_match，
regex_search()，regex_match()，regex_replace()
●regex_contants：
标志用于控制regex、match、replace行为
●regex：(seq，flag)
●sregex_iterator：(b，e，r)
默认初始化为end
●sregex_token_iterator：(b，e，r，init)
最后一个实参用int或初始列指定：-1保存匹配间的子字符串
●smatch：
存放ssub_match的容器
●ssub_match：
指向表达式匹配到的子表达式

○Stream：<iostream><fstream><sstream> <iomanip>
●状态与异常：
注意：当stream会反复使用时，注意要恢复其状态
●非格式化I/O成员函数：
每一次I/O仍然需要sentry对象进行预处理和后处理
●预定义I/O运算符：
整型：
[0-9]*，[0-8]*，
((0(x|X))|[0-9a-fA-F])[0-9a-fA-F]*
浮点型：
[0-9]+\.?[0-9]*(e[+-]?[0-9]+)?  ，
\.[0-9]+(e[+-]?[0-9]+)?
bool，char，char*，void*，string，streambuf*，bitset，complex
●关联stream：
以.tie()和.tie(ostream&)关联，在I/O该stream时冲刷关联的ostream
以.rdbuf()和.rdbuf(streambuf*)关联，对同一缓冲区建立多个stream对象
以.copyfmt()传递所有格式信息
●关于性能
ios::sync_with_stdio(false)：关闭C-stream同步与多线程同步机制
cin.(nullptr)：关闭cin与cout的关联
○streambuf：<streambuf>
●销毁问题：basic_i/ostream析构时不会销毁，其他stream析构时只是不销毁.rdbuf()得到的
●高效非格式化I/O：
streambuf_iterator：不通过stream对象直接I/O缓冲区
streambuf*：利用stream.rdbuf()获取后直接调用I/O运算符与另一个流缓冲区对接，注意输入时需要std::noskipws
○locale：<locale>
●locale：封装了多个facet用于多方面信息本地化
●facet：数值、货币、时间、编码
●locale的构造：
默认："C"
智能：""
自定义："zh_CN.UTF-8[@modifier]"
●提供.name()和::global(locale)
○Stream库总览：<iofwd>
●组件：
streambuf(系统I/O并缓存数据，提供位置信息)
locale(包含facet将I/O进行进行本地格式化)
stream(封装上述两者，提供状态、格式化信息)
centry(帮助stream每次I/O预处理与后处理)
操作符(提供调整stream的便捷方法)
std::ios(定义了一些标志位)
●I/O时根据外部主机环境确定Stream的信息：
charT：每次I/O处理多少字节
语系环境：对数值、货币、日期等格式化
字符集：可将字符转换到另一个字符集
●主要特性：
利用运算符与操作符进行格式化I/O
对同一个streambuf建立多个stream
利用streambuf进行高效非格式化I/O
利用stream对locale的接口进行本地化和国际化
利用locale提供的操作符格式化日期时间
编码转换用wchar_t存储utf8字符便于比较、处理
●字符处理：
<cctype>：字符比较
<codecvt>：字符编码转换器
例：
typedef codecvt_utf8<wchar_t> utf8
wstring_convert<utf8> convertor
wbuffer_convert<utf8> wbuf_utf8(stream.rdbuf())
●对于UTF-8：
▪高位结束字节以110/1110等等开头而非0，以向后兼容C字符集(0-127)，以免将变长字符的一部分按ascii码处理
▪低位字节10开头而非1，以区分低位字节与高位结束字节
▪以故程序与用户若只需处理C字符则默认状态也能正常进行，并不改变多字节字符编码；但若想处理后者则需要编码转换先将字符装入wchar_t，但输出时又要转换回char，因为utf-8的OS无法正确识别wchar_t对应的宽字符

○随机数生成器：<random>
●引擎
默认初始化的种子都一样
●分布
产生指定分布类型与范围的随机数
○complex：<complex>
并发
○线程：<thread> <future>
●async()：
封装并启动线程函数，将其返回值存到shared data
发射策略：launch::async、launch::deferred
●future<>和shared_future<>：
可获取shared data，还包括状态，句柄，异常
等待状态 : future_status::deferred | timeout | ready
●this_thread::
控制本线程、获取TID

○并发问题
●访问共享数据：
数据竞争、数据销毁
●编译器优化：
访存优化、顺序优化
○互斥锁：<mutex> 
●组件：
mutex，recursive_mutex
timed_mutex、timed_recursive_mutex
shared_mutex、shared_timed_mutex
lock_guard<>、unique_lock<>、shared_lock<>
lock(，)，try_lock(，)
once_flag、call_once()
●unique_lock模式：
adopt_lock、defer_lock、try_lock
●提供原子性操作：
读取mutex - 判断mutex - 上锁或阻塞
解锁-唤醒
○条件量：<condition_variable>
●依赖于unique_lock<>提供保护区
●提供.wait...()和.notify...()
●应该在保护区外使用.notify...()
●等待状态：cv_status::time_out/no_timeout
●提供原子性操作：
解锁-阻塞
唤醒
○原子性：<atomic>
●不保证代码次序
●不依赖阻塞-唤醒(使用循环一直检测)
●原子性操作机制：
操作的目标在操作期间只有自己能访问
