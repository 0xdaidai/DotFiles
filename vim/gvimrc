set listchars+=eol:↵
set gfn=Source\ Code\ Pro\ Black\ Italic\ 10.5  " 命令行输入 set gfn=* 打开系统字体选择面板
" set gfn=Hack\ Bold\ Italic\ 10
" set gfn=IBM\ Plex\ Mono\ SemiBold\ Italic\ 10.5
set guioptions=agit
set guicursor=n:block,i:hor10,a:blinkon0
set background=dark

colorscheme one
" 注意，以下后排注释为其余搭配的Airline主题，Airline的atomic主题会改变状态栏格式，不喜欢的可以把源码中的第55行开始的那段代码注释
" 注意，let g:airline_theme应该放在Airline加载前，本配置在vimrc中
" colorscheme NeoSolarized | let g:airline_theme="atomic"     " angr, solarized, solarized_flood
" colorscheme tender       | let g:airline_theme="tender"     " cool
" colorscheme one          | let g:airline_theme="one"        " fruit_punch, fairyfloss
" colorscheme palenight    | let g:airline_theme="fairyfloss" " palenight
" colorscheme neodark      | let g:airline_theme="night_owl"  " neodark, behelit
" colorscheme gruvbox      | let g:airline_theme="alduin"     " gruvbox, fairyfloss

set cursorline           " 高亮显示当前行
" set cursorcolumn       " 高亮显示当前行，次选项可能导致光标移动的延迟

" 切换窗口时自动关闭和打开高亮行列
autocmd WinLeave * set nocul
autocmd WinEnter * set cul


"================================
" => Startify配置
"================================
" 开启devicons图标
function! StartifyEntryFormat()
    return 'WebDevIconsGetFileTypeSymbol(absolute_path) ." ". entry_path'
endfunction
let g:ascii = [
            \ '                                       ^   ',
            \ '                                _     /|   ',
            \ '                              _( \_/)/ /   ',
            \ '                              ,((((^/\/    ',
            \ '                              ((((  (*~\   ',
            \ '                           ,((((( ,     \  ',
            \ '        ,,,_              ,(((((  /"._  ,`,',
            \ '       ((((\\ ,...       ,((((   /    `-.-`',
            \ '       )))  ;`    `"`"`""((((   (          ',
            \ '     (((  /            ((       \          ',
            \ '      ((  |        .       "     \         ',
            \ '      ))  \     _ `      `t   ,.`)         ',
            \ '      (   |   y;- -,-""-"-.\   \/          ',
            \ '     )   / ./  ) /.         `\  \          ',
            \ '         |./   ( (           / /`          ',
            \ '         ||     \\          //`|           ',
            \ '         ||     _")       _//`||           ',
            \ '         ||    |_/       |_/  ||           ',
            \ '         \_\                  ||           ',
            \ '         ``"                  \_\          ',
            \ ]
let g:startify_custom_header =
          \ 'startify#pad(g:ascii + startify#fortune#boxed())'



"================================
" => Tagbar配置
"================================
let g:tagbar_left=1
let g:tagbar_width = 30
noremap <silent> <F2> :TagbarToggle<CR>


"================================
" => NERDTree配置
"================================
let NERDTreeMinimalUI=1     " NERDTree 子窗口中不显示冗余帮助信息
let NERDTreeWinPos='right'
noremap <silent> <F3> :NERDTreeToggle<CR>:wincmd p<CR>


"================================
" => UltiSnips配置  
"================================
" 设置<C-C>触发UltiSnips补全，解决UltiSnips与YCM按键冲突网上有教程加两个函数与映射解决，我更愿意如此
let g:UltiSnipsExpandTrigger = '<c-c>'
let g:UltiSnipsJumpBackwardTrigger = '<M-b>'
let g:UltiSnipsJumpForwardTrigger = '<M-m>'


"================================
" => YCM配置
"================================
" 添加白名单，节省性能资源
let g:ycm_filetype_whitelist = { 
        \ "c":1,
        \ "cpp":1,
        \ "vim":1,
        \ "sh":1,
        \ "zsh":1,
        \ }
" 两个字符便触发语义补全，由此导致Snips无法显示在补全列表
let g:ycm_semantic_triggers =  {
        \ 'c,cpp,python,java,sh': ['re!\w{2}'],
        \ }
let g:ycm_add_preview_to_completeopt = 0    " 不显示预览窗口
set completeopt=menu,menuone                " 不显示预览窗口
let g:ycm_use_clangd = 0                    " 只用libclang不用clangd
let g:ycm_show_diagnostics_ui = 0           " 不进行语法检测
let g:ycm_confirm_extra_conf=0              " 自动确认 .ycm_confirm_extra_conf
let g:ycm_cache_omnifunc=0                  " 禁止缓存匹配项，每次都重新生成匹配项
let g:ycm_seed_identifiers_with_syntax=1    " 语法关键字补全
let g:ycm_key_invoke_completion = '<c-z>'   " 按 <c-c> 手动触发语义补全
let g:ycm_min_num_identifier_candidate_chars = 2
let g:ycm_complete_in_comments=0
let g:ycm_complete_in_strings=0
let g:ycm_collect_identifiers_from_comments_and_strings = 0
let g:ycm_collect_identifiers_from_tags_files = 0
let g:ycm_key_list_stop_completion = ['<CR>']
nnoremap gp :YcmCompleter GetParent<CR>
nnoremap gt :YcmCompleter GetType<CR>
nnoremap go :YcmCompleter GoTo<CR>


"================================
" => ALE配置
"================================
" 显示指定linters
let g:ale_linters = {
      \   'cpp': ['clang', 'clangtidy', 'gcc', 'cppcheck'],
      \   'c': ['gcc', 'cppcheck'],
      \   'python': ['pylint'],
      \   'sh': ['shell'],
\}
let g:ale_linters_explicit = 1
let g:ale_sign_column_always = 1
let g:ale_disable_lsp = 1
let g:ale_completion_enabled = 0
let g:ale_echo_delay = 20
let g:ale_lint_delay = 500
let g:ale_set_highlights = 0
let g:ale_echo_msg_format = '[%linter%] %s  [%severity%]'
let g:ale_lint_on_text_changed = 'normal'
let g:ale_lint_on_insert_leave = 1
let g:ale_lint_on_enter = 0
let g:ale_c_gcc_options = '-Wall -Wextra -O2 -std=c11'
let g:ale_c_cppcheck_options = '--enable=all -std=c11'
let g:ale_cpp_gcc_options = '-Wall -Wextra -O2 -std=c++17'
let g:ale_cpp_cppcheck_options = '--enable=warning,style,performance,portability,information --std=c++17'
let g:ale_cpp_clang_options = '-Weverything -Wno-c++98-compat -Wno-c++98-compat-pedantic -Wno-pedantic -Wno-padded -Wno-old-style-cast -O2 -std=c++17'
let g:ale_cpp_clangtidy_options = '-extra-arg=-std=c++17'
let g:ale_sign_error = '✗'
let g:ale_sign_warning = '‼'
let g:ale_sign_info = '⚡'
let g:ale_echo_msg_error_str = '✗'
let g:ale_echo_msg_warning_str = '‼'
let g:ale_echo_msg_info_str = '⚡'
let g:ale_statusline_format = ['✗ %d', '⚡ %d', '✔ OK']
hi! clear SpellBad
hi! clear SpellCap
hi! clear SpellRare
hi! SpellBad gui=undercurl guisp=red
hi! SpellCap gui=undercurl guisp=yellow
hi! SpellRare gui=undercurl guisp=magenta
nnoremap <silent> jn :ALENextWrap<CR>
nnoremap <silent> jb :ALEPreviousWrap<CR>
nnoremap <silent> <space>a :ALEDetail<CR>:wincmd p<cr>


"================================
" => Asyncrun配置
"================================
" let g:asyncrun_open = 7     " 非零则执行命令后开启quickfix窗口，窗口高度为该变量的值
" let g:asyncrun_bell = 1   " 任务结束时候响铃提醒

" 此句会造成gvim启动崩溃，故加在zshrc中
" if !isdirectory('/tmp/QuickRun')
"     !mkdir /tmp/QuickRun
" endif


"================================
" => QuickRun配置
"================================
let g:QuickRunArgs=''
let g:QuickRunRedirect=''
let g:QuickRunBufnr=0
command! -nargs=1 QuickrunArgs let g:QuickRunArgs = <q-args>
command! -nargs=1 QuickrunRedirect let g:QuickRunRedirect = <q-args>
function! QuickRun(mode)
    let QuickRun_TIME = strftime('%M%H')
    let QuickRun_FILE = expand('%:t')
    let QuickRun_PATH = '/tmp/QuickRun/' . QuickRun_FILE . '.' . QuickRun_TIME
    write
    if g:QuickRunBufnr !=0 && bufexists(g:QuickRunBufnr)
        execute 'bd ' . g:QuickRunBufnr
    endif
    rightbelow 15 split
    if a:mode == 0
        execute 'term ++noclose ++norestore ++curwin sh -c "echo -e \"\\e[1;32m[Compile] ' . QuickRun_PATH .
                    \ '\\e[m\" && g++ -std=c++17 -O3 -I. -o ' . QuickRun_PATH .' ' . expand('%') .
                    \ ' && quickrun_time ' . g:QuickRunRedirect . ' ' . QuickRun_PATH . ' ' . g:QuickRunArgs . '"'
    else
        execute 'term ++noclose ++norestore ++curwin sh -c "echo -e \"\\e[1;32m[Compile] ' . QuickRun_PATH .
                    \ '\\e[m\" && g++ -std=c++17 -ggdb -Og -g -fno-inline -D_GLIBCXX_DEBUG -D_GLIBCXX_DEBUG_PEDANTIC -I. -o ' .
                    \ QuickRun_PATH . ' ' . expand('%') . '"'
    endif
    let g:QuickRunBufnr=bufnr('%')
    wincmd p
endfunction
nnoremap <silent> <space>lr :call QuickRun(0)<CR>
nnoremap <silent> <space>ld :call QuickRun(1)<CR>
nnoremap <silent> <space>lc :execute '!clang++ -std=c++17 -O3 -o ' . expand('%:r') . ' ' . expand('%')<CR>



"================================
" => Rainbow-Parentheses配置
"================================
au VimEnter * RainbowParenthesesToggle
au Syntax * RainbowParenthesesLoadRound
au Syntax * RainbowParenthesesLoadSquare
au Syntax * RainbowParenthesesLoadBraces


"================================
" => Echodoc配置
"================================
let g:echodoc#enable_at_startup = 1
autocmd VimEnter * EchoDocEnable


"================================
" => Cpp_Enhanced_Highlight配置
"================================
let g:cpp_class_scope_highlight = 1
let g:cpp_member_variable_highlight = 1
let g:cpp_class_decl_highlight = 1
let g:cpp_posix_standard = 1
" let g:cpp_experimental_simple_template_highlight = 1  " which works in most cases, but can be a little slow on large files
let g:cpp_experimental_template_highlight = 1           " which is a faster implementation but has some corner cases where it doesn't work.
let g:cpp_concepts_highlight = 1
let g:cpp_no_function_highlight = 1


"===============================
" => 手动加载GVIM专用插件
"===============================
call plug#load('vim-startify',
	    \ 'rainbow_parentheses.vim',
            \ 'indentLine',
            \ 'ale',
            \ 'youcompleteme',
            \ 'echodoc.vim',
	    \)
