set listchars=tab:▸\ ,trail:∙,eol:↵,extends:↷,precedes:↶    " 设置空白符如何显示
set ambiwidth=double                                        " 解决devicon只显示一半图标的问题
set gfn=Source\ Code\ Pro\ Black\ Italic\ 10.5              " 命令行输入 set gfn=* 打开系统字体选择面板
set guioptions=agitd                                        " 不显示菜单
set guicursor=n:block,i:hor10,a:blinkon0
set cursorline                                              " 高亮显示当前行
" set cursorcolumn       " 高亮显示当前行，此选项可能导致光标移动的延迟

colorscheme neodark
" 注意，以下后排注释为其余搭配的Airline主题，Airline的atomic主题会改变状态栏格式，不喜欢的可以把源码中的第55行开始的那段代码注释
" 注意，let g:airline_theme应该放在Airline加载前，本配置在vimrc中
" colorscheme NeoSolarized | let g:airline_theme="atomic"     " angr, solarized, solarized_flood, cool
" colorscheme one          | let g:airline_theme="one"        " fruit_punch, fairyfloss
" colorscheme palenight    | let g:airline_theme="fairyfloss" " palenight, base16_harmonic16
" colorscheme neodark      | let g:airline_theme="night_owl"  " neodark, behelit
" colorscheme gruvbox      | let g:airline_theme="alduin"     " gruvbox, fairyfloss

" 切换窗口时自动关闭和打开高亮行列
autocmd WinLeave * set nocul
autocmd WinEnter * set cul

function! ToggleAmbiwidth()
    if &ambiwidth == bouble
        set ambiwidth=single
    else
        set ambiwidth=double
    endif
endfunction
nnoremap <silent> <leader>a :call ToggleAmbiwidth()<cr>

"================================
" => Startify配置
"================================
" 开启devicons图标
function! StartifyEntryFormat()
    return 'WebDevIconsGetFileTypeSymbol(absolute_path) ." ". entry_path'
endfunction
let g:ascii = [
            \ '                                       ^   ',
            \ '                                _     /|   ',
            \ '                              _( \_/)/ /   ',
            \ '                              ,((((^/\/    ',
            \ '                              ((((  (*~\   ',
            \ '                           ,((((( ,     \  ',
            \ '        ,,,_              ,(((((  /"._  ,`,',
            \ '       ((((\\ ,...       ,((((   /    `-.-`',
            \ '       )))  ;`    `"`"`""((((   (          ',
            \ '     (((  /            ((       \          ',
            \ '      ((  |        .       "     \         ',
            \ '      ))  \     _ `      `t   ,.`)         ',
            \ '      (   |   y;- -,-""-"-.\   \/          ',
            \ '     )   / ./  ) /.         `\  \          ',
            \ '         |./   ( (           / /`          ',
            \ '         ||     \\          //`|           ',
            \ '         ||     _")       _//`||           ',
            \ '         ||    |_/       |_/  ||           ',
            \ '         \_\                  ||           ',
            \ '         ``"                  \_\          ',
            \ ]
let g:startify_custom_header =
          \ 'startify#pad(g:ascii + startify#fortune#boxed())'

"================================
" => UltiSnips配置
"================================
" 设置<C-C>触发UltiSnips补全，解决UltiSnips与YCM按键冲突网上有教程加两个函数与映射解决，我更愿意如此
let g:UltiSnipsExpandTrigger = '<c-c>'
let g:UltiSnipsJumpBackwardTrigger = '<M-b>'
let g:UltiSnipsJumpForwardTrigger = '<M-m>'


"================================
" => ALE配置
"================================
" 显示指定linters
let g:ale_linters = {
      \   'cpp': ['clang', 'clangtidy', 'gcc', 'cppcheck'],
      \   'c': ['gcc', 'cppcheck'],
      \   'sh': ['shell'],
      \}
let g:ale_linters_explicit = 1
let g:ale_sign_column_always = 1
let g:ale_disable_lsp = 1
let g:ale_completion_enabled = 0
let g:ale_set_highlights = 1
let g:ale_echo_msg_format = '[%linter%] %s  [%severity%]'
let g:ale_lint_on_text_changed = 'never'
let g:ale_lint_on_insert_leave = 1
let g:ale_lint_on_enter = 0
let g:ale_c_gcc_options = '-Wall -Wextra -O2 -std=c11'
let g:ale_c_cppcheck_options = '--enable=all -std=c11'
let g:ale_cpp_gcc_options = '-Wall -Wextra -O2 -std=c++17'
let g:ale_cpp_cppcheck_options = '--enable=warning,style,performance,portability,information --std=c++17'
let g:ale_cpp_clang_options = '-Weverything -Wno-c++98-compat -Wno-c++98-compat-pedantic -Wno-pedantic -Wno-missing-prototypes -Wno-padded -Wno-old-style-cast -O2 -std=c++17'
let g:ale_cpp_clangtidy_options = '-extra-arg=-std=c++17'
let g:ale_sign_error = '✗'
let g:ale_sign_warning = '‼'
let g:ale_sign_info = '⚡'
let g:ale_echo_msg_error_str = '✗'
let g:ale_echo_msg_warning_str = '‼'
let g:ale_echo_msg_info_str = '⚡'
let g:ale_statusline_format = ['✗ %d', '⚡ %d', '✔ OK']
hi! clear SpellBad
hi! clear SpellCap
hi! clear SpellRare
hi! SpellBad gui=undercurl guisp=red
hi! SpellCap gui=undercurl guisp=yellow
hi! SpellRare gui=undercurl guisp=magenta
nnoremap <silent> jn :ALENextWrap<CR>
nnoremap <silent> jb :ALEPreviousWrap<CR>
nnoremap <silent> <space>a :ALEDetail<CR>:wincmd p<cr>

"================================
" => Asyncrun配置
"================================
" let g:asyncrun_open = 7     " 非零则执行命令后开启quickfix窗口，窗口高度为该变量的值
" let g:asyncrun_bell = 1   " 任务结束时候响铃提醒

"================================
" => QuickRun配置
"================================
let g:QuickRunArgs=''
let g:QuickRunRedirect=''
let g:QuickRunBufnr=0
let g:QuickRun_PATH=''
command! -nargs=1 QuickrunArgs let g:QuickRunArgs = <q-args>
command! -nargs=1 QuickrunRedirect let g:QuickRunRedirect = <q-args>
function! QuickRun()
    if !isdirectory('/tmp/QuickRun') 
        !mkdir /tmp/QuickRun
    endif
    if g:QuickRunBufnr != 0 && bufexists(g:QuickRunBufnr)
        execute 'bd ' . g:QuickRunBufnr
    endif
    if &modified == 0 && g:QuickRun_PATH =~ expand('%:t')
        rightbelow 15 split
        execute 'term ++noclose ++norestore ++curwin sh -c "echo -e \"\\e[1;33mRerunning last compiled program!\\e[m\" && quickrun_time '
                    \ . g:QuickRunRedirect . ' ' . g:QuickRun_PATH . ' ' . g:QuickRunArgs . '"'
    else
        write
        rightbelow 15 split
        let QuickRun_TIME = strftime('%M%H')
        let QuickRun_FILE = expand('%:t')
        let g:QuickRun_PATH = '/tmp/QuickRun/' . QuickRun_FILE . '.' . QuickRun_TIME
        execute 'term ++noclose ++norestore ++curwin sh -c "echo -e \"\\e[1;32m[Compile] ' . g:QuickRun_PATH .
                    \ '\\e[m\" && g++ -std=c++17 -O2 -I. -o ' . g:QuickRun_PATH .' ' . expand('%') .
                    \ ' && quickrun_time ' . g:QuickRunRedirect . ' ' . g:QuickRun_PATH . ' ' . g:QuickRunArgs . '"'
    endif
    let g:QuickRunBufnr=bufnr('%')
    wincmd p
endfunction
nnoremap <silent> <space>lr :call QuickRun()<CR>
nnoremap <silent> <space>ld :execute '!clang++ -std=c++17 -ggdb -Og -g -fno-inline -D_GLIBCXX_DEBUG -D_GLIBCXX_DEBUG_PEDANTIC -I. -o ' . expand('%:r') . ' ' . expand('%')<CR>
nnoremap <silent> <space>lc :execute '!clang++ -std=c++17 -O3 -I. -o ' . expand('%:r') . ' ' . expand('%')<CR>

"================================
" => Echodoc配置
"================================
let g:echodoc#enable_at_startup = 1
autocmd VimEnter * EchoDocEnable

"================================
" => Cpp_Enhanced_Highlight配置
"================================
let g:cpp_class_scope_highlight = 1
let g:cpp_member_variable_highlight = 1
let g:cpp_class_decl_highlight = 1
let g:cpp_posix_standard = 1
" let g:cpp_experimental_simple_template_highlight = 1  " which works in most cases, but can be a little slow on large files
let g:cpp_experimental_template_highlight = 1           " which is a faster implementation but has some corner cases where it doesn't work.
" let g:cpp_concepts_highlight = 1
" let g:cpp_no_function_highlight = 1

"===============================
" => 手动加载GVIM专用插件
"===============================
call plug#load('vim-startify',
            \ 'ale',
            \ 'echodoc.vim',
	    \)

